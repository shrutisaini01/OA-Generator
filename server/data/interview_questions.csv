topic,title,description,solution
Arrays,Two Sum,"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to the target.","function twoSum(nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    const diff = target - nums[i];
    if (map.has(diff)) return [map.get(diff), i];
    map.set(nums[i], i);
  }
}"
Strings,Longest Palindromic Substring,"Given a string s, return the longest palindromic substring in s.","function longestPalindrome(s) {
  let res = '';
  for (let i = 0; i < s.length; i++) {
    let odd = expand(i, i);
    let even = expand(i, i + 1);
    let longer = odd.length > even.length ? odd : even;
    if (longer.length > res.length) res = longer;
  }
  return res;

  function expand(l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) l--, r++;
    return s.slice(l + 1, r);
  }
}"
Trees,Maximum Depth of Binary Tree,"Given the root of a binary tree, return its maximum depth.","function maxDepth(root) {
  if (!root) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}"
Graphs,Number of Connected Components,"Given n nodes and a list of edges, return the number of connected components in an undirected graph.","function countComponents(n, edges) {
  const parent = Array(n).fill(0).map((_, i) => i);

  function find(x) {
    while (x !== parent[x]) x = parent[x] = parent[parent[x]];
    return x;
  }

  function union(x, y) {
    const rootX = find(x);
    const rootY = find(y);
    if (rootX !== rootY) {
      parent[rootY] = rootX;
      n--;
    }
  }

  for (let [a, b] of edges) union(a, b);
  return n;
}"
Dynamic Programming,0/1 Knapsack,"Given weights, values, and capacity, return the maximum value that can be put in a knapsack of given capacity.","function knapsack(W, wt, val, n) {
  const dp = Array(n + 1).fill(0).map(() => Array(W + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let w = 0; w <= W; w++) {
      if (wt[i - 1] <= w)
        dp[i][w] = Math.max(val[i - 1] + dp[i - 1][w - wt[i - 1]], dp[i - 1][w]);
      else
        dp[i][w] = dp[i - 1][w];
    }
  }
  return dp[n][W];
}"
